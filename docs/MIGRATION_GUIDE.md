# üîÑ MIGRATION GUIDE - FILE TILE WIDGET

## üéØ PrzeglƒÖd

Ten przewodnik pomo≈ºe Ci migrowaƒá z legacy `FileTileWidget` API na nowƒÖ architekturƒô komponentowƒÖ. Wszystkie zmiany zachowujƒÖ backward compatibility.

## üìã Checklista Migracji

### ‚úÖ Etap 1: Przygotowanie
- [ ] Backup istniejƒÖcego kodu
- [ ] Zidentyfikuj wszystkie u≈ºycia FileTileWidget
- [ ] Sprawd≈∫ deprecated warnings w logach

### ‚úÖ Etap 2: Podstawowa Migracja
- [ ] ZastƒÖp deprecated metody
- [ ] Zaktualizuj importy
- [ ] Przetestuj funkcjonalno≈õƒá

### ‚úÖ Etap 3: Optymalizacja
- [ ] Wykorzystaj nowe komponenty
- [ ] Dodaj event handling
- [ ] Zoptymalizuj performance

### ‚úÖ Etap 4: Testowanie
- [ ] Uruchom testy
- [ ] Sprawd≈∫ memory usage
- [ ] Weryfikuj UI responsiveness

## üîß SZCZEG√ì≈ÅOWA MIGRACJA

### 1. Importy

**Przed:**
```python
from src.ui.widgets.file_tile_widget import FileTileWidget
```

**Po:**
```python
from src.ui.widgets.file_tile_widget import FileTileWidget
from src.ui.widgets.tile_config import TileConfig
from src.ui.widgets.tile_event_bus import TileEvent, TileEventBus
from src.ui.widgets.tile_resource_manager import TileResourceManager
```

### 2. Tworzenie Widgetu

**Przed:**
```python
# Podstawowe tworzenie
tile = FileTileWidget(file_pair)

# Z custom rozmiarem
tile = FileTileWidget(file_pair)
tile.change_thumbnail_size((300, 300))
```

**Po:**
```python
# Podstawowe tworzenie (bez zmian)
tile = FileTileWidget(file_pair)

# Z konfiguracjƒÖ (zalecane)
config = TileConfig(thumbnail_size=(300, 300))
tile = FileTileWidget(file_pair, config=config)

# Lub predefiniowane konfiguracje
config = TileConfig.small()   # 150x150
config = TileConfig.large()   # 350x350
tile = FileTileWidget(file_pair, config=config)
```

### 3. ZarzƒÖdzanie Danymi

**Przed:**
```python
# Aktualizacja danych
tile.update_data(new_file_pair)

# Pobieranie danych
file_pair = tile.get_file_data()
```

**Po:**
```python
# Aktualizacja danych (nowe API)
tile.set_file_pair(new_file_pair)

# Pobieranie danych (property)
file_pair = tile.file_pair

# Legacy API nadal dzia≈Ça (z deprecation warning)
tile.update_data(new_file_pair)  # ‚ö†Ô∏è DEPRECATED
file_pair = tile.get_file_data()  # ‚ö†Ô∏è DEPRECATED
```

### 4. ZarzƒÖdzanie Miniaturkami

**Przed:**
```python
# Zmiana rozmiaru
tile.change_thumbnail_size((250, 250))

# Prze≈Çadowanie
tile.refresh_thumbnail()
```

**Po:**
```python
# Zmiana rozmiaru (nowe API)
tile.set_thumbnail_size((250, 250))

# Prze≈Çadowanie (nowe API)
tile.reload_thumbnail()

# Legacy API nadal dzia≈Ça
tile.change_thumbnail_size((250, 250))  # ‚ö†Ô∏è DEPRECATED
tile.refresh_thumbnail()  # ‚ö†Ô∏è DEPRECATED
```

### 5. ZarzƒÖdzanie SelekcjƒÖ

**Przed:**
```python
# Ustawienie selekcji
tile.set_selection(True)

# Sprawdzenie selekcji
is_selected = tile.is_selected()
```

**Po:**
```python
# Ustawienie selekcji (nowe API)
tile.set_selected(True)

# Sprawdzenie selekcji (property)
is_selected = tile.is_selected

# Legacy API nadal dzia≈Ça
tile.set_selection(True)  # ‚ö†Ô∏è DEPRECATED
```

### 6. Metadane (Nowa Funkcjonalno≈õƒá)

**Przed:**
```python
# Brak bezpo≈õredniego API dla metadanych
# Metadane by≈Çy zarzƒÖdzane przez zewnƒôtrzne komponenty
```

**Po:**
```python
# Bezpo≈õredni dostƒôp do metadanych
metadata = tile._metadata_component

# Gwiazdki (0-5)
metadata.set_stars(4)
stars = metadata.stars

# Tagi kolor√≥w (hex string)
metadata.set_color_tag("#FF0000")
color = metadata.color_tag

# Selekcja
metadata.set_selected(True)
is_selected = metadata.is_selected

# Snapshot metadanych
snapshot = metadata.get_metadata_snapshot()
```

### 7. Event Handling (Nowa Funkcjonalno≈õƒá)

**Przed:**
```python
# Brak centralnego event systemu
# Eventy by≈Çy obs≈Çugiwane przez sygna≈Çy Qt
tile.thumbnail_clicked.connect(callback)
```

**Po:**
```python
# Event bus dla komunikacji miƒôdzy komponentami
event_bus = tile.event_bus

# Subskrypcja event√≥w
def on_thumbnail_loaded(path: str, pixmap: QPixmap):
    print(f"Thumbnail loaded: {path}")

event_bus.subscribe(TileEvent.THUMBNAIL_LOADED, on_thumbnail_loaded)
event_bus.subscribe(TileEvent.DATA_UPDATED, on_data_updated)
event_bus.subscribe(TileEvent.STATE_CHANGED, on_state_changed)

# Emisja event√≥w
event_bus.emit_event(TileEvent.USER_INTERACTION, "click")

# Legacy sygna≈Çy Qt nadal dzia≈ÇajƒÖ
tile.thumbnail_clicked.connect(callback)
```

### 8. Resource Management (Nowa Funkcjonalno≈õƒá)

**Przed:**
```python
# Brak centralnego zarzƒÖdzania zasobami
# Ka≈ºdy widget zarzƒÖdza≈Ç swoimi zasobami
```

**Po:**
```python
# Centralne zarzƒÖdzanie zasobami
resource_manager = TileResourceManager.get_instance()

# Rejestracja kafelka
resource_manager.register_tile(tile)

# Sprawdzenie u≈ºycia pamiƒôci
stats = resource_manager.get_memory_usage()
print(f"Memory: {stats.current_mb:.2f} MB")

# Automatyczny cleanup
resource_manager.perform_cleanup()

# Custom limity
from src.ui.widgets.tile_resource_manager import ResourceLimits
limits = ResourceLimits(max_tiles=500, max_memory_mb=200)
manager = TileResourceManager.get_instance(limits)
```

## üöÄ ZAAWANSOWANE FUNKCJONALNO≈öCI

### 1. Asynchroniczne Operacje UI

```python
# Dostƒôp do async UI manager
async_ui_manager = tile._async_ui_manager

# Debouncing operacji
def update_ui():
    tile.reload_thumbnail()

async_ui_manager.debounce_manager.debounce(
    "thumbnail_update", 
    update_ui, 
    delay_ms=100
)

# Batch updates
def update_function():
    tile.set_thumbnail_size((200, 200))

async_ui_manager.batch_updater.add_update(update_function)
async_ui_manager.batch_updater.flush()
```

### 2. Performance Monitoring

```python
# Dostƒôp do performance monitor
performance_monitor = tile._performance_monitor

# Sprawdzenie metryk
metrics = performance_monitor.get_metrics()
print(f"Render time: {metrics.render_time_ms:.2f} ms")
print(f"Memory usage: {metrics.memory_usage_mb:.2f} MB")

# Cache optimization
cache_optimizer = tile._cache_optimizer
cache_stats = cache_optimizer.get_cache_stats()
print(f"Cache hit rate: {cache_stats.hit_rate:.1%}")
```

### 3. Custom Konfiguracja

```python
# Pe≈Çna custom konfiguracja
config = TileConfig(
    thumbnail_size=(400, 400),
    padding=24,
    filename_height=80,
    metadata_height=30,
    font_size_range=(10, 22),
    font_scale_factor=10
)

tile = FileTileWidget(file_pair, config=config)
```

## ‚ö†Ô∏è DEPRECATED API - DO USUNIƒòCIA

### Metody kt√≥re zostanƒÖ usuniƒôte w przysz≈Çych wersjach:

```python
# ‚ö†Ô∏è DEPRECATED - zastƒÖp set_file_pair()
widget.update_data(file_pair)

# ‚ö†Ô∏è DEPRECATED - zastƒÖp file_pair property
widget.get_file_data()

# ‚ö†Ô∏è DEPRECATED - zastƒÖp set_thumbnail_size()
widget.change_thumbnail_size(size)

# ‚ö†Ô∏è DEPRECATED - zastƒÖp reload_thumbnail()
widget.refresh_thumbnail()

# ‚ö†Ô∏è DEPRECATED - zastƒÖp set_selected()
widget.set_selection(selected)
```

### Deprecation Warnings

Wszystkie deprecated metody pokazujƒÖ warning przy pierwszym u≈ºyciu:

```
DeprecationWarning: FileTileWidget.update_data() is deprecated. Use set_file_pair() instead.
```

## üìä PRZYK≈ÅADY MIGRACJI

### Przyk≈Çad 1: Podstawowy Widget

**Przed:**
```python
from src.ui.widgets.file_tile_widget import FileTileWidget

# Tworzenie
tile = FileTileWidget(file_pair)

# Aktualizacja danych
tile.update_data(new_file_pair)

# Zmiana rozmiaru
tile.change_thumbnail_size((250, 250))

# Selekcja
tile.set_selection(True)

# Event handling
tile.thumbnail_clicked.connect(on_click)
```

**Po:**
```python
from src.ui.widgets.file_tile_widget import FileTileWidget
from src.ui.widgets.tile_config import TileConfig

# Tworzenie z konfiguracjƒÖ
config = TileConfig(thumbnail_size=(250, 250))
tile = FileTileWidget(file_pair, config=config)

# Aktualizacja danych
tile.set_file_pair(new_file_pair)

# Zmiana rozmiaru
tile.set_thumbnail_size((250, 250))

# Selekcja
tile.set_selected(True)

# Event handling (legacy + nowe)
tile.thumbnail_clicked.connect(on_click)  # Legacy Qt signals
tile.event_bus.subscribe(TileEvent.THUMBNAIL_LOADED, on_loaded)  # Nowe events
```

### Przyk≈Çad 2: Zaawansowany Widget

**Przed:**
```python
from src.ui.widgets.file_tile_widget import FileTileWidget

class CustomTileWidget(FileTileWidget):
    def __init__(self, file_pair):
        super().__init__(file_pair)
        self.setup_custom_behavior()
    
    def setup_custom_behavior(self):
        self.change_thumbnail_size((300, 300))
        self.set_selection(False)
    
    def update_tile_data(self, new_data):
        self.update_data(new_data)
        self.refresh_thumbnail()
```

**Po:**
```python
from src.ui.widgets.file_tile_widget import FileTileWidget
from src.ui.widgets.tile_config import TileConfig
from src.ui.widgets.tile_event_bus import TileEvent

class CustomTileWidget(FileTileWidget):
    def __init__(self, file_pair):
        # Custom konfiguracja
        config = TileConfig(thumbnail_size=(300, 300))
        super().__init__(file_pair, config=config)
        
        self.setup_custom_behavior()
    
    def setup_custom_behavior(self):
        # Metadane przez komponent
        self._metadata_component.set_selected(False)
        
        # Event subscription
        self.event_bus.subscribe(TileEvent.DATA_UPDATED, self.on_data_updated)
    
    def update_tile_data(self, new_data):
        # Nowe API
        self.set_file_pair(new_data)
        self.reload_thumbnail()
    
    def on_data_updated(self, file_pair):
        # Custom logic po aktualizacji danych
        print(f"Data updated: {file_pair.get_base_name()}")
```

### Przyk≈Çad 3: Batch Operations

**Przed:**
```python
# Brak batch operations
for file_pair in file_pairs:
    tile = FileTileWidget(file_pair)
    tile.change_thumbnail_size((200, 200))
    tile.set_selection(False)
```

**Po:**
```python
from src.ui.widgets.tile_resource_manager import TileResourceManager

# Resource management
resource_manager = TileResourceManager.get_instance()

# Batch operations
for file_pair in file_pairs:
    tile = FileTileWidget(file_pair)
    
    # Rejestracja w resource manager
    resource_manager.register_tile(tile)
    
    # Batch updates przez async UI manager
    async_ui_manager = tile._async_ui_manager
    async_ui_manager.batch_updater.add_update(
        lambda t=tile: t.set_thumbnail_size((200, 200))
    )
    async_ui_manager.batch_updater.add_update(
        lambda t=tile: t.set_selected(False)
    )

# Flush wszystkich updates
async_ui_manager.batch_updater.flush()
```

## üîß TROUBLESHOOTING

### Problem: Deprecation warnings w logach

**Objawy:**
```
DeprecationWarning: FileTileWidget.update_data() is deprecated
```

**RozwiƒÖzanie:**
```python
# Przed
tile.update_data(file_pair)

# Po
tile.set_file_pair(file_pair)
```

### Problem: Memory leaks

**Objawy:** RosnƒÖce u≈ºycie pamiƒôci przy wielu kafelkach

**RozwiƒÖzanie:**
```python
# Dodaj resource management
resource_manager = TileResourceManager.get_instance()
resource_manager.register_tile(tile)

# Sprawd≈∫ memory usage
stats = resource_manager.get_memory_usage()
if stats.current_mb > 100:  # 100MB limit
    resource_manager.perform_cleanup()
```

### Problem: Slow thumbnail loading

**Objawy:** Wolne ≈Çadowanie miniaturek

**RozwiƒÖzanie:**
```python
# U≈ºyj async UI manager
async_ui_manager = tile._async_ui_manager

# Debounce thumbnail updates
async_ui_manager.debounce_manager.debounce(
    "thumbnail_load", 
    tile.reload_thumbnail, 
    delay_ms=200
)
```

### Problem: Event not firing

**Objawy:** Callback nie jest wywo≈Çywany

**RozwiƒÖzanie:**
```python
# Sprawd≈∫ czy callback jest zarejestrowany
def on_event(data):
    print(f"Event received: {data}")

# Subskrybuj siƒô na event
tile.event_bus.subscribe(TileEvent.DATA_UPDATED, on_event)

# Sprawd≈∫ czy event jest emitowany
tile.event_bus.emit_event(TileEvent.DATA_UPDATED, "test_data")
```

## üìà PERFORMANCE OPTIMIZATION

### 1. Memory Optimization

```python
# U≈ºyj predefiniowanych konfiguracji
config = TileConfig.small()  # Mniejsze miniaturki = mniej pamiƒôci

# Resource management
resource_manager = TileResourceManager.get_instance()
resource_manager.register_tile(tile)

# Periodic cleanup
import threading
import time

def periodic_cleanup():
    while True:
        time.sleep(300)  # Co 5 minut
        resource_manager.perform_cleanup()

cleanup_thread = threading.Thread(target=periodic_cleanup, daemon=True)
cleanup_thread.start()
```

### 2. UI Responsiveness

```python
# Async UI operations
async_ui_manager = tile._async_ui_manager

# Batch updates dla lepszej wydajno≈õci
def update_multiple_tiles(tiles):
    for tile in tiles:
        async_ui_manager.batch_updater.add_update(
            lambda t=tile: t.set_thumbnail_size((200, 200))
        )
    async_ui_manager.batch_updater.flush()
```

### 3. Cache Optimization

```python
# Dostƒôp do cache optimizer
cache_optimizer = tile._cache_optimizer

# Sprawd≈∫ cache performance
stats = cache_optimizer.get_cache_stats()
if stats.hit_rate < 0.8:  # <80% hit rate
    cache_optimizer.optimize_cache()
```

## ‚úÖ TESTING MIGRACJI

### 1. Unit Tests

```python
import pytest
from src.ui.widgets.file_tile_widget import FileTileWidget

def test_new_api():
    tile = FileTileWidget(file_pair)
    
    # Test nowego API
    tile.set_file_pair(new_file_pair)
    assert tile.file_pair == new_file_pair
    
    tile.set_thumbnail_size((200, 200))
    tile.reload_thumbnail()
    
    tile.set_selected(True)
    assert tile.is_selected == True

def test_legacy_api_compatibility():
    tile = FileTileWidget(file_pair)
    
    # Legacy API nadal dzia≈Ça
    tile.update_data(new_file_pair)  # ‚ö†Ô∏è DEPRECATED
    tile.change_thumbnail_size((200, 200))  # ‚ö†Ô∏è DEPRECATED
    tile.set_selection(True)  # ‚ö†Ô∏è DEPRECATED
```

### 2. Integration Tests

```python
def test_component_integration():
    tile = FileTileWidget(file_pair)
    
    # Test komponent√≥w
    assert tile._thumbnail_component is not None
    assert tile._metadata_component is not None
    assert tile._interaction_component is not None
    assert tile.event_bus is not None

def test_event_bus():
    tile = FileTileWidget(file_pair)
    
    events_received = []
    
    def on_event(data):
        events_received.append(data)
    
    tile.event_bus.subscribe(TileEvent.DATA_UPDATED, on_event)
    tile.event_bus.emit_event(TileEvent.DATA_UPDATED, "test")
    
    assert len(events_received) == 1
    assert events_received[0] == "test"
```

### 3. Performance Tests

```python
import time
import psutil

def test_memory_usage():
    process = psutil.Process()
    initial_memory = process.memory_info().rss / 1024 / 1024  # MB
    
    tiles = []
    for i in range(100):
        tile = FileTileWidget(file_pair)
        tiles.append(tile)
    
    final_memory = process.memory_info().rss / 1024 / 1024  # MB
    memory_per_tile = (final_memory - initial_memory) / 100
    
    assert memory_per_tile < 10  # <10MB per tile
```

## üéØ PODSUMOWANIE

### Co zosta≈Ço zmienione:

1. **API Methods**: `update_data()` ‚Üí `set_file_pair()`, `change_thumbnail_size()` ‚Üí `set_thumbnail_size()`
2. **Properties**: `get_file_data()` ‚Üí `file_pair` property, `is_selected()` ‚Üí `is_selected` property
3. **Architecture**: Monolityczna klasa ‚Üí Component-based architecture
4. **Event System**: Qt signals ‚Üí Event bus + Qt signals
5. **Resource Management**: Manual ‚Üí Automatic przez TileResourceManager

### Co zosta≈Ço zachowane:

1. **Backward Compatibility**: Wszystkie legacy API nadal dzia≈Ça
2. **Qt Signals**: Wszystkie istniejƒÖce sygna≈Çy Qt dzia≈ÇajƒÖ
3. **External API**: Integracja z GalleryManager i innymi komponentami
4. **Functionality**: Wszystkie funkcjonalno≈õci zachowane

### Co zosta≈Ço dodane:

1. **Component Architecture**: Separacja concerns na komponenty
2. **Event Bus**: Centralna komunikacja miƒôdzy komponentami
3. **Resource Management**: Automatyczne zarzƒÖdzanie zasobami
4. **Performance Optimization**: Async operations, caching, batching
5. **Configuration System**: Flexible configuration przez TileConfig

---

**Wersja przewodnika:** 1.0  
**Data aktualizacji:** 2025-01-27  
**Kompatybilno≈õƒá:** FileTileWidget v2.0+ 