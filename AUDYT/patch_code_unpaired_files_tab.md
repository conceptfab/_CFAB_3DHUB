# üìù FRAGMENTY KODU DO POPRAWEK - unpaired_files_tab.py

## üéØ ETAP 1.1: ELIMINACJA DUPLIKACJI KODU

### **1.1.1 USUNIƒòCIE KLASY UnpairedPreviewTile**

**PLIK:** `src/ui/widgets/unpaired_files_tab.py`  
**LINIE:** 41-282  
**AKCJA:** USU≈É CA≈ÅƒÑ KLASƒò

```python
# USU≈É CA≈ÅƒÑ KLASƒò UnpairedPreviewTile (linie 41-282)
# ZastƒÖp u≈ºyciem FileTileWidget z flagƒÖ show_metadata=False
```

### **1.1.2 DODANIE METODY W FileTileWidget**

**PLIK:** `src/ui/widgets/file_tile_widget.py`  
**LINIE:** Po metodzie `__init__`  
**AKCJA:** DODAJ METODƒò

```python
@classmethod
def create_simple_tile(cls, file_pair, parent=None, show_metadata=False):
    """
    Tworzy uproszczony kafelek bez metadanych.

    Args:
        file_pair: Obiekt FilePair
        parent: Widget nadrzƒôdny
        show_metadata: Czy pokazywaƒá metadane (gwiazdki, tagi)

    Returns:
        FileTileWidget z ukrytymi metadanymi
    """
    tile = cls(file_pair, parent=parent)
    if not show_metadata:
        tile._metadata_component.hide()
    return tile
```

## üéØ ETAP 1.2: UPROSZCZENIE LOGIKI CHECKBOX√ìW

### **1.2.1 UPROSZCZENIE METODY \_on_preview_checkbox_changed**

**PLIK:** `src/ui/widgets/unpaired_files_tab.py`  
**LINIE:** 498-533  
**AKCJA:** ZASTƒÑP

```python
def _on_preview_checkbox_changed(self, checkbox, preview_path, state):
    """
    Obs≈Çuguje zmianƒô stanu checkboxa - uproszczona wersja.
    """
    if state == Qt.CheckState.Checked.value:
        # Znajd≈∫ i zaznacz element w li≈õcie
        for i in range(self.unpaired_previews_list_widget.count()):
            item = self.unpaired_previews_list_widget.item(i)
            if item.data(Qt.ItemDataRole.UserRole) == preview_path:
                self.unpaired_previews_list_widget.setCurrentItem(item)
                break
    else:
        # Odznacz element w li≈õcie
        current_item = self.unpaired_previews_list_widget.currentItem()
        if (current_item and
            current_item.data(Qt.ItemDataRole.UserRole) == preview_path):
            self.unpaired_previews_list_widget.setCurrentItem(None)

    # Aktualizuj stan przycisku
    self._update_pair_button_state()
```

## üéØ ETAP 1.3: OPTYMALIZACJA LOGOWANIA

### **1.3.1 ZMIANA POZIOM√ìW LOG√ìW**

**PLIK:** `src/ui/widgets/unpaired_files_tab.py`  
**LINIE:** 316, 325, 330, 335, 340, 345, 350, 355, 360, 365, 370, 375, 380, 385  
**AKCJA:** ZMIE≈É INFO ‚Üí DEBUG

```python
# ZMIE≈É WSZYSTKIE logging.debug() NA logging.debug()
# USU≈É NADMIAROWE LOGI DLA OPERACJI UI

def create_unpaired_files_tab(self) -> QWidget:
    """Tworzy zak≈Çadkƒô niesparowanych plik√≥w."""
    # USU≈É: logging.debug("Creating unpaired files tab")

    self.unpaired_files_tab = QWidget()
    self.unpaired_files_layout = QVBoxLayout(self.unpaired_files_tab)
    self.unpaired_files_layout.setContentsMargins(5, 5, 5, 5)
    # USU≈É: logging.debug("Basic widget and layout created")

    # Splitter dla dw√≥ch list
    self.unpaired_splitter = QSplitter()
    # USU≈É: logging.debug("Splitter created")

    # Lista niesparowanych archiw√≥w
    # USU≈É: logging.debug("Creating archives list")
    self._create_unpaired_archives_list()
    # USU≈É: logging.debug("Archives list created successfully")

    # Lista niesparowanych podglƒÖd√≥w
    # USU≈É: logging.debug("Creating previews list")
    self._create_unpaired_previews_list()
    # USU≈É: logging.debug("Previews list created successfully")

    # ... reszta kodu bez log√≥w
```

### **1.3.2 KONSOLIDACJA KOMUNIKAT√ìW B≈ÅƒòD√ìW**

**PLIK:** `src/ui/widgets/unpaired_files_tab.py`  
**LINIE:** 468-497  
**AKCJA:** UPRO≈öƒÜ

```python
def _show_preview_dialog(self, preview_path: str):
    """Wy≈õwietla okno dialogowe z podglƒÖdem obrazu."""
    if not preview_path or not os.path.exists(preview_path):
        QMessageBox.warning(
            self.main_window, "Brak PodglƒÖdu", "Plik podglƒÖdu nie istnieje."
        )
        return

    try:
        pixmap = QPixmap(preview_path)
        if pixmap.isNull():
            raise ValueError("Nie uda≈Ço siƒô za≈Çadowaƒá obrazu.")

        dialog = PreviewDialog(pixmap, self.main_window)
        dialog.exec()

    except Exception as e:
        logging.error(f"B≈ÇƒÖd ≈Çadowania podglƒÖdu: {e}")
        QMessageBox.critical(
            self.main_window, "B≈ÇƒÖd PodglƒÖdu", f"Nie uda≈Ço siƒô za≈Çadowaƒá podglƒÖdu: {e}"
        )
```

## üéØ ETAP 1.4: ELIMINACJA FALLBACK CODE

### **1.4.1 UPROSZCZENIE METODY update_unpaired_files_lists**

**PLIK:** `src/ui/widgets/unpaired_files_tab.py`  
**LINIE:** 610-703  
**AKCJA:** ZASTƒÑP

```python
def update_unpaired_files_lists(self):
    """Aktualizuje listy niesparowanych plik√≥w w interfejsie u≈ºytkownika."""
    # Sprawd≈∫ czy widgety istniejƒÖ
    if not self.unpaired_archives_list or not self.unpaired_previews_grid:
        logging.error("Brak wymaganych widget√≥w do zarzƒÖdzania plikami")
        return

    archives_count = len(self.main_window.controller.unpaired_archives)
    previews_count = len(self.main_window.controller.unpaired_previews)

    # Wyczy≈õƒá widgety
    self.unpaired_archives_list.clear()
    self.unpaired_previews_grid.clear()

    # Wyczy≈õƒá listy pomocnicze
    self.preview_checkboxes.clear()
    self.preview_tile_widgets.clear()

    # Sortuj alfabetycznie
    sorted_archives = sorted(
        self.main_window.controller.unpaired_archives,
        key=lambda x: os.path.basename(x).lower(),
    )
    sorted_previews = sorted(
        self.main_window.controller.unpaired_previews,
        key=lambda x: os.path.basename(x).lower(),
    )

    # Aktualizuj widgety
    self.unpaired_archives_list.update_archives(sorted_archives)
    self.unpaired_previews_grid.update_previews(sorted_previews)

    self._update_pair_button_state()
```

### **1.4.2 UPROSZCZENIE METODY clear_unpaired_files_lists**

**PLIK:** `src/ui/widgets/unpaired_files_tab.py`  
**LINIE:** 589-609  
**AKCJA:** ZASTƒÑP

```python
def clear_unpaired_files_lists(self):
    """Czy≈õci listy niesparowanych plik√≥w w interfejsie u≈ºytkownika."""
    if self.unpaired_archives_list:
        self.unpaired_archives_list.clear()
    if self.unpaired_previews_grid:
        self.unpaired_previews_grid.clear()

    self.preview_checkboxes.clear()
    self.preview_tile_widgets.clear()
```

## üéØ ETAP 1.5: KONSOLIDACJA OPERACJI

### **1.5.1 WSP√ìLNA METODA DO RAPORTOWANIA**

**PLIK:** `src/ui/widgets/unpaired_files_tab.py`  
**LINIE:** Po metodzie `__init__`  
**AKCJA:** DODAJ METODƒò

```python
def _show_operation_report(self, operation_name: str, result: dict, success_message: str):
    """
    Wsp√≥lna metoda do wy≈õwietlania raport√≥w z operacji.

    Args:
        operation_name: Nazwa operacji
        result: Wynik operacji
        success_message: Komunikat sukcesu
    """
    total_requested = result.get("total_requested", 0)
    successfully_processed = result.get("successfully_processed", 0)
    errors = result.get("errors", 0)

    if errors == 0:
        QMessageBox.information(
            self.main_window, f"{operation_name} zako≈Ñczone", success_message
        )
    else:
        report_lines = [
            f"{operation_name} zako≈Ñczone z b≈Çƒôdami:",
            f"‚Ä¢ Pomy≈õlnie przetworzono: {successfully_processed}",
            f"‚Ä¢ B≈Çƒôdy: {errors}",
            f"‚Ä¢ ≈ÅƒÖcznie: {total_requested}",
        ]

        detailed_errors = result.get("detailed_errors", [])
        if detailed_errors:
            report_lines.append("")
            report_lines.append("Szczeg√≥≈Çy b≈Çƒôd√≥w:")
            for error in detailed_errors[:5]:
                file_name = os.path.basename(error.get("file_path", "Nieznany"))
                error_type = error.get("error_type", "NIEZNANY")
                report_lines.append(f"‚Ä¢ {file_name}: {error_type}")

            if len(detailed_errors) > 5:
                report_lines.append(f"... i {len(detailed_errors) - 5} wiƒôcej b≈Çƒôd√≥w")

        QMessageBox.warning(
            self.main_window, f"{operation_name} zako≈Ñczone z b≈Çƒôdami", "\n".join(report_lines)
        )
```

### **1.5.2 UPROSZCZENIE METOD RAPORTOWANIA**

**PLIK:** `src/ui/widgets/unpaired_files_tab.py`  
**LINIE:** 839-883  
**AKCJA:** ZASTƒÑP

```python
def _show_move_unpaired_report(self, moved_files: list, detailed_errors: list, summary: dict):
    """Wy≈õwietla raport z przenoszenia plik√≥w bez pary."""
    result = {
        "total_requested": summary.get("total_requested", 0),
        "successfully_processed": summary.get("successfully_moved", 0),
        "errors": summary.get("errors", 0),
        "detailed_errors": detailed_errors
    }

    self._show_operation_report(
        "Przenoszenie",
        result,
        f"Pomy≈õlnie przeniesiono {result['successfully_processed']} z {result['total_requested']} plik√≥w archiwum bez pary do folderu '_bez_pary_'."
    )
```

## üéØ ETAP 1.6: NOWA STRUKTURA PLIK√ìW

### **1.6.1 NOWY PLIK: unpaired_files_tab_core.py**

**PLIK:** `src/ui/widgets/unpaired_files_tab_core.py`  
**AKCJA:** UTW√ìRZ NOWY PLIK

```python
"""
G≈Ç√≥wna logika zak≈Çadki niesparowanych plik√≥w - wydzielona z unpaired_files_tab.py.
"""

import logging
import os
from typing import TYPE_CHECKING

from PyQt6.QtCore import Qt
from PyQt6.QtWidgets import QMessageBox

if TYPE_CHECKING:
    from src.ui.main_window import MainWindow


class UnpairedFilesTabCore:
    """G≈Ç√≥wna logika zak≈Çadki niesparowanych plik√≥w."""

    def __init__(self, main_window: "MainWindow"):
        self.main_window = main_window
        self.logger = logging.getLogger(__name__)

    def update_lists(self, archives_list, previews_grid):
        """Aktualizuje listy niesparowanych plik√≥w."""
        if not archives_list or not previews_grid:
            self.logger.error("Brak wymaganych widget√≥w")
            return

        archives = self.main_window.controller.unpaired_archives
        previews = self.main_window.controller.unpaired_previews

        # Sortuj alfabetycznie
        sorted_archives = sorted(archives, key=lambda x: os.path.basename(x).lower())
        sorted_previews = sorted(previews, key=lambda x: os.path.basename(x).lower())

        # Aktualizuj widgety
        archives_list.update_archives(sorted_archives)
        previews_grid.update_previews(sorted_previews)

    def clear_lists(self, archives_list, previews_grid):
        """Czy≈õci listy niesparowanych plik√≥w."""
        if archives_list:
            archives_list.clear()
        if previews_grid:
            previews_grid.clear()

    def show_operation_report(self, operation_name: str, result: dict, success_message: str):
        """Wy≈õwietla raport z operacji."""
        total = result.get("total_requested", 0)
        success = result.get("successfully_processed", 0)
        errors = result.get("errors", 0)

        if errors == 0:
            QMessageBox.information(self.main_window, f"{operation_name} zako≈Ñczone", success_message)
        else:
            report = [
                f"{operation_name} zako≈Ñczone z b≈Çƒôdami:",
                f"‚Ä¢ Pomy≈õlnie: {success}",
                f"‚Ä¢ B≈Çƒôdy: {errors}",
                f"‚Ä¢ ≈ÅƒÖcznie: {total}",
            ]
            QMessageBox.warning(self.main_window, f"{operation_name} zako≈Ñczone z b≈Çƒôdami", "\n".join(report))
```

### **1.6.2 NOWY PLIK: unpaired_files_operations.py**

**PLIK:** `src/ui/widgets/unpaired_files_operations.py`  
**AKCJA:** UTW√ìRZ NOWY PLIK

```python
"""
Operacje na niesparowanych plikach - wydzielone z unpaired_files_tab.py.
"""

import logging
import os
from typing import TYPE_CHECKING

from PyQt6.QtWidgets import QMessageBox

from src.ui.delegates.workers.file_list_workers import BulkDeleteFilesWorker

if TYPE_CHECKING:
    from src.ui.main_window import MainWindow


class UnpairedFilesOperations:
    """Operacje na niesparowanych plikach."""

    def __init__(self, main_window: "MainWindow"):
        self.main_window = main_window
        self.logger = logging.getLogger(__name__)

    def handle_manual_pairing(self, archives_list_widget, previews_list_widget):
        """Obs≈Çuguje rƒôczne parowanie plik√≥w."""
        if hasattr(self.main_window, "file_operations_ui"):
            current_directory = self.main_window.controller.current_directory
            self.main_window.file_operations_ui.handle_manual_pairing(
                archives_list_widget,
                previews_list_widget,
                current_directory,
            )

    def handle_move_unpaired_archives(self, unpaired_archives: list):
        """Obs≈Çuguje przenoszenie niesparowanych archiw√≥w."""
        current_directory = self.main_window.controller.current_directory
        if not current_directory:
            QMessageBox.warning(self.main_window, "Brak folderu roboczego", "Nie wybrano folderu roboczego.")
            return

        if not unpaired_archives:
            QMessageBox.information(self.main_window, "Brak plik√≥w", "Nie ma plik√≥w archiwum bez pary do przeniesienia.")
            return

        reply = QMessageBox.question(
            self.main_window,
            "Potwierdzenie przeniesienia",
            f"Czy na pewno chcesz przenie≈õƒá {len(unpaired_archives)} plik√≥w archiwum bez pary do folderu '_bez_pary_'?",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
            QMessageBox.StandardButton.No,
        )

        if reply != QMessageBox.StandardButton.Yes:
            return

        target_folder = os.path.join(current_directory, "_bez_pary_")
        try:
            os.makedirs(target_folder, exist_ok=True)
        except Exception as e:
            QMessageBox.critical(self.main_window, "B≈ÇƒÖd tworzenia folderu", f"Nie uda≈Ço siƒô utworzyƒá folderu '_bez_pary_': {e}")
            return

        self._start_move_worker(unpaired_archives, target_folder)

    def handle_delete_unpaired_previews(self, unpaired_previews: list):
        """Obs≈Çuguje usuwanie niesparowanych podglƒÖd√≥w."""
        if not unpaired_previews:
            QMessageBox.information(self.main_window, "Informacja", "Brak nieparowanych podglƒÖd√≥w do usuniƒôcia.")
            return

        reply = QMessageBox.question(
            self.main_window,
            "Potwierdzenie usuniƒôcia",
            f"Czy na pewno chcesz trwale usunƒÖƒá {len(unpaired_previews)} plik√≥w podglƒÖdu z dysku?",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
            QMessageBox.StandardButton.No,
        )

        if reply == QMessageBox.StandardButton.Yes:
            self._start_delete_worker(unpaired_previews)

    def _start_move_worker(self, files_to_move: list, target_folder: str):
        """Uruchamia workera do przenoszenia plik√≥w."""
        self.main_window.worker_manager.run_worker(
            BulkMoveFilesWorker,
            files_to_move=files_to_move,
            destination_folder=target_folder,
            source_folder=self.main_window.controller.current_directory,
        )

    def _start_delete_worker(self, files_to_delete: list):
        """Uruchamia workera do usuwania plik√≥w."""
        self.main_window.worker_manager.run_worker(
            BulkDeleteFilesWorker,
            on_finished=self._on_delete_finished,
            on_error=self._on_delete_error,
            show_progress=True,
            files_to_delete=files_to_delete,
        )

    def _on_delete_finished(self, result: dict):
        """Obs≈Çuguje zako≈Ñczenie usuwania."""
        deleted_files = result.get("deleted_files", [])
        errors = result.get("errors", [])
        self.main_window.progress_manager.hide_progress()

        QMessageBox.information(
            self.main_window,
            "Operacja zako≈Ñczona",
            f"Usuniƒôto {len(deleted_files)} z {len(deleted_files) + len(errors)} plik√≥w podglƒÖdu.\nLiczba b≈Çƒôd√≥w: {len(errors)}.",
        )

    def _on_delete_error(self, error_message: str):
        """Obs≈Çuguje b≈Çƒôdy podczas usuwania."""
        self.main_window.progress_manager.hide_progress()
        QMessageBox.critical(self.main_window, "B≈ÇƒÖd usuwania", f"WystƒÖpi≈Ç b≈ÇƒÖd podczas usuwania plik√≥w: {error_message}")
```

### **1.6.3 NOWY PLIK: unpaired_files_tab.py (REFACTORED)**

**PLIK:** `src/ui/widgets/unpaired_files_tab.py`  
**AKCJA:** ZASTƒÑP CA≈ÅY PLIK

```python
"""
Zak≈Çadka niesparowanych plik√≥w - zrefaktoryzowana wersja.
"""

import logging
from typing import TYPE_CHECKING

from PyQt6.QtCore import Qt
from PyQt6.QtWidgets import (
    QHBoxLayout,
    QPushButton,
    QVBoxLayout,
    QWidget,
)

from src.ui.widgets.unpaired_archives_list import UnpairedArchivesList
from src.ui.widgets.unpaired_previews_grid import UnpairedPreviewsGrid
from src.ui.widgets.unpaired_files_tab_core import UnpairedFilesTabCore
from src.ui.widgets.unpaired_files_operations import UnpairedFilesOperations

if TYPE_CHECKING:
    from src.ui.main_window import MainWindow


class UnpairedFilesTab:
    """ZarzƒÖdza zak≈ÇadkƒÖ niesparowanych plik√≥w - zrefaktoryzowana wersja."""

    def __init__(self, main_window: "MainWindow"):
        self.main_window = main_window
        self.logger = logging.getLogger(__name__)

        # Komponenty
        self.core = UnpairedFilesTabCore(main_window)
        self.operations = UnpairedFilesOperations(main_window)

        # Widgety
        self.unpaired_files_tab = None
        self.unpaired_files_layout = None
        self.unpaired_splitter = None
        self.unpaired_archives_list = None
        self.unpaired_previews_grid = None
        self.pair_manually_button = None
        self.delete_unpaired_previews_button = None
        self.move_unpaired_button = None

    def create_unpaired_files_tab(self) -> QWidget:
        """Tworzy zak≈Çadkƒô niesparowanych plik√≥w."""
        self.unpaired_files_tab = QWidget()
        self.unpaired_files_layout = QVBoxLayout(self.unpaired_files_tab)
        self.unpaired_files_layout.setContentsMargins(5, 5, 5, 5)

        # Splitter dla dw√≥ch list
        self.unpaired_splitter = QSplitter()

        # Lista niesparowanych archiw√≥w
        self._create_unpaired_archives_list()

        # Lista niesparowanych podglƒÖd√≥w
        self._create_unpaired_previews_list()

        self.unpaired_files_layout.addWidget(self.unpaired_splitter)

        # Panel przycisk√≥w
        self._create_buttons_panel()

        return self.unpaired_files_tab

    def _create_unpaired_archives_list(self):
        """Tworzy listƒô niesparowanych archiw√≥w."""
        self.unpaired_archives_list = UnpairedArchivesList(self.main_window)
        self.unpaired_archives_list.selection_changed.connect(self._update_pair_button_state)
        self.unpaired_splitter.addWidget(self.unpaired_archives_list)

    def _create_unpaired_previews_list(self):
        """Tworzy panel niesparowanych podglƒÖd√≥w."""
        self.unpaired_previews_grid = UnpairedPreviewsGrid(self.main_window)
        self.unpaired_previews_grid.selection_changed.connect(self._update_pair_button_state)
        self.unpaired_splitter.addWidget(self.unpaired_previews_grid)

    def _create_buttons_panel(self):
        """Tworzy panel przycisk√≥w."""
        buttons_panel = QWidget()
        buttons_panel.setFixedHeight(35)
        buttons_layout = QHBoxLayout(buttons_panel)
        buttons_layout.setContentsMargins(5, 2, 5, 2)
        buttons_layout.setSpacing(10)

        # Przycisk do rƒôcznego parowania
        self.pair_manually_button = QPushButton("‚úÖ Sparuj manualnie")
        self.pair_manually_button.setToolTip("Sparuj zaznaczone archiwum z zaznaczonym podglƒÖdem")
        self.pair_manually_button.setMinimumHeight(40)
        self.pair_manually_button.clicked.connect(self._handle_manual_pairing)
        self.pair_manually_button.setEnabled(False)
        buttons_layout.addWidget(self.pair_manually_button)

        # Przycisk do usuwania podglƒÖd√≥w
        self.delete_unpaired_previews_button = QPushButton("üóëÔ∏è Usu≈Ñ podglƒÖdy bez pary")
        self.delete_unpaired_previews_button.setToolTip("Usuwa z dysku wszystkie pliki podglƒÖd√≥w z tej listy")
        self.delete_unpaired_previews_button.setMinimumHeight(40)
        self.delete_unpaired_previews_button.clicked.connect(self._handle_delete_unpaired_previews)
        buttons_layout.addWidget(self.delete_unpaired_previews_button)

        # Przycisk do przenoszenia archiw√≥w
        self.move_unpaired_button = QPushButton("üöö Przenie≈õ archiwa")
        self.move_unpaired_button.setToolTip("Przenosi wszystkie pliki archiwum bez pary do folderu '_bez_pary_'")
        self.move_unpaired_button.setMinimumHeight(40)
        self.move_unpaired_button.clicked.connect(self._handle_move_unpaired_archives)
        buttons_layout.addWidget(self.move_unpaired_button)

        self.unpaired_files_layout.addWidget(buttons_panel)

    def _update_pair_button_state(self):
        """Aktualizuje stan przycisku do rƒôcznego parowania."""
        if not self.pair_manually_button:
            return

        selected_archives = self.unpaired_archives_list.list_widget.selectedItems()
        selected_previews = self.unpaired_previews_grid.hidden_list_widget.selectedItems()

        self.pair_manually_button.setEnabled(
            len(selected_archives) == 1 and len(selected_previews) == 1
        )

    def _handle_manual_pairing(self):
        """Obs≈Çuguje logikƒô rƒôcznego parowania plik√≥w."""
        self.operations.handle_manual_pairing(
            self.unpaired_archives_list.list_widget,
            self.unpaired_previews_grid.hidden_list_widget
        )

    def _handle_move_unpaired_archives(self):
        """Obs≈Çuguje przenoszenie niesparowanych archiw√≥w."""
        unpaired_archives = self.main_window.controller.unpaired_archives
        self.operations.handle_move_unpaired_archives(unpaired_archives)

    def _handle_delete_unpaired_previews(self):
        """Obs≈Çuguje usuwanie niesparowanych podglƒÖd√≥w."""
        unpaired_previews = self.unpaired_previews_grid.get_all_preview_paths()
        self.operations.handle_delete_unpaired_previews(unpaired_previews)

    def clear_unpaired_files_lists(self):
        """Czy≈õci listy niesparowanych plik√≥w."""
        self.core.clear_lists(self.unpaired_archives_list, self.unpaired_previews_grid)

    def update_unpaired_files_lists(self):
        """Aktualizuje listy niesparowanych plik√≥w."""
        self.core.update_lists(self.unpaired_archives_list, self.unpaired_previews_grid)
        self._update_pair_button_state()

    def update_thumbnail_size(self, new_size):
        """Aktualizuje rozmiar miniaturek."""
        if self.unpaired_previews_grid:
            self.unpaired_previews_grid.update_thumbnail_size(new_size)

    def get_widgets_for_main_window(self):
        """Zwraca referencje do widget√≥w potrzebnych w main_window."""
        return {
            "unpaired_files_tab": self.unpaired_files_tab,
            "unpaired_archives_list_widget": self.unpaired_archives_list.list_widget,
            "unpaired_previews_list_widget": self.unpaired_previews_grid.hidden_list_widget,
            "unpaired_previews_layout": self.unpaired_previews_grid.grid_layout,
            "pair_manually_button": self.pair_manually_button,
        }
```

---

## ‚úÖ CHECKLISTA IMPLEMENTACJI

### **ETAP 1.1: Podzia≈Ç na komponenty**

- [ ] Utworzenie `unpaired_files_tab_core.py`
- [ ] Utworzenie `unpaired_files_operations.py`
- [ ] Refaktoryzacja `unpaired_files_tab.py`

### **ETAP 1.2: Eliminacja duplikacji**

- [ ] Usuniƒôcie klasy `UnpairedPreviewTile`
- [ ] Dodanie metody `create_simple_tile()` w `FileTileWidget`
- [ ] Uproszczenie logiki checkbox√≥w

### **ETAP 1.3: Optymalizacja logowania**

- [ ] Zmiana INFO ‚Üí DEBUG dla operacji rutynowych
- [ ] Usuniƒôcie nadmiarowych log√≥w
- [ ] Konsolidacja komunikat√≥w b≈Çƒôd√≥w

### **ETAP 1.4: Uproszczenie architektury**

- [ ] Eliminacja fallback code
- [ ] Redukcja sprawdze≈Ñ hasattr()
- [ ] Uproszczenie metod pomocniczych

### **ETAP 1.5: Testy**

- [ ] Test funkcjonalno≈õci podstawowej
- [ ] Test integracji
- [ ] Test wydajno≈õci
- [ ] Test regresyjny

---

**STATUS:** üîÑ **GOTOWY DO IMPLEMENTACJI** - Wszystkie fragmenty kodu przygotowane.
